{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. 1. Theoretical Foundation Governing Equations Projectile motion follows Newton\u2019s second law, and we assume motion under constant acceleration due to gravity, ignoring air resistance. The horizontal motion is governed by: $$ x = v_0 \\cos(\\theta) t $$ The vertical motion follows: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Solving for the time of flight when the projectile returns to the ground ( \\( \\(y=0\\) \\) ): \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range, which is the horizontal distance traveled, is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Family of Solutions The range is maximized when \\( \\(\\theta = 45^\\circ\\) \\) , as \\( \\(\\sin(2\\theta)\\) \\) reaches its peak at this angle. Different values of \\( \\(v_0\\) \\) and \\( \\(g\\) \\) shift the entire curve up or down, affecting the overall range. 2. Analysis of the Range The function $$ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ follows a sinusoidal form, reaching its peak at 45 degrees. Increasing \\( \\(v_0\\) \\) increases the range quadratically. A higher gravitational acceleration \\( \\(g\\) \\) decreases the range. If the projectile is launched from a height \\( \\(h\\) \\) , the range expression becomes more complex: $$ R = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g h} \\right) $$ 3. Practical Applications Sports : Understanding optimal angles for long jumps, soccer kicks, or basketball shots. Engineering : Ballistics and missile trajectory calculations. Astrophysics : Studying celestial bodies\u2019 motion in the absence of air resistance. 4. Implementation Below is a Python script to simulate and visualize the range as a function of the launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) # Angles in degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range as a Function of Angle') plt.legend() plt.grid() plt.show() # Example usage projectile_range(v0=20, g=9.81) 5. Discussion on Model Limitations The model assumes no air resistance, which is unrealistic for real-world projectiles. Wind and drag force significantly alter projectile motion. For high-speed objects, Coriolis effects (due to Earth's rotation) might need to be considered. Uneven terrain or varying gravitational acceleration can affect actual projectile behavior. 6. Conclusion This study highlights the interplay between angle, velocity, and gravity in determining a projectile\u2019s range. The insights gained are applicable across sports, engineering, and even astrophysics. Future work can involve adding air resistance to the model for a more realistic simulation.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"Projectile motion follows Newton\u2019s second law, and we assume motion under constant acceleration due to gravity, ignoring air resistance. The horizontal motion is governed by: $$ x = v_0 \\cos(\\theta) t $$ The vertical motion follows: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ Solving for the time of flight when the projectile returns to the ground ( \\( \\(y=0\\) \\) ): \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range, which is the horizontal distance traveled, is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The range is maximized when \\( \\(\\theta = 45^\\circ\\) \\) , as \\( \\(\\sin(2\\theta)\\) \\) reaches its peak at this angle. Different values of \\( \\(v_0\\) \\) and \\( \\(g\\) \\) shift the entire curve up or down, affecting the overall range.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The function $$ R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ follows a sinusoidal form, reaching its peak at 45 degrees. Increasing \\( \\(v_0\\) \\) increases the range quadratically. A higher gravitational acceleration \\( \\(g\\) \\) decreases the range. If the projectile is launched from a height \\( \\(h\\) \\) , the range expression becomes more complex: $$ R = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g h} \\right) $$","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Understanding optimal angles for long jumps, soccer kicks, or basketball shots. Engineering : Ballistics and missile trajectory calculations. Astrophysics : Studying celestial bodies\u2019 motion in the absence of air resistance.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate and visualize the range as a function of the launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) # Angles in degrees radians = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * radians)) / g # Compute range plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'Initial Velocity = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range as a Function of Angle') plt.legend() plt.grid() plt.show() # Example usage projectile_range(v0=20, g=9.81)","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion-on-model-limitations","text":"The model assumes no air resistance, which is unrealistic for real-world projectiles. Wind and drag force significantly alter projectile motion. For high-speed objects, Coriolis effects (due to Earth's rotation) might need to be considered. Uneven terrain or varying gravitational acceleration can affect actual projectile behavior.","title":"5. Discussion on Model Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-conclusion","text":"This study highlights the interplay between angle, velocity, and gravity in determining a projectile\u2019s range. The insights gained are applicable across sports, engineering, and even astrophysics. Future work can involve adding air resistance to the model for a more realistic simulation.","title":"6. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance. 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. For small angles, we approximate \\(\\sin\\theta \\approx \\theta\\) , leading to the linearized equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) is close to the system's natural frequency \\(\\omega_0\\) . This leads to an increase in amplitude, potentially causing instability or breakdown of the approximation. 2. Analysis of Dynamics The damping coefficient \\(b\\) controls energy dissipation. The driving amplitude \\(A\\) determines how strongly the external force influences the motion. The driving frequency \\(\\omega\\) dictates whether resonance or chaotic motion occurs. The transition to chaotic motion can be studied by analyzing phase space diagrams and Poincar\u00e9 sections. 3. Practical Applications Energy Harvesting : Used in piezoelectric devices that convert mechanical vibrations into electrical energy. Structural Engineering : Suspension bridges and tall buildings experience forced oscillations due to wind and earthquakes. Electronics : Analogous to driven RLC circuits in electrical engineering. 4. Implementation To analyze the forced damped pendulum, we use Python to numerically solve the governing differential equation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equation of motion for the forced damped pendulum def forced_damped_pendulum(t, y, b, omega0, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving force frequency # Initial conditions theta0 = 0.1 # Initial angle omega_dot0 = 0 # Initial angular velocity y0 = [theta0, omega_dot0] # Time range for the simulation t_span = (0, 50) # Simulation time t_eval = np.linspace(*t_span, 1000) # Time steps # Solve the differential equation solution = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, omega0, A, omega)) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=r'$\\theta(t)$', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() 5. Discussion on Model Limitations The model assumes a simple sinusoidal driving force; real-world forces may be more complex. Air resistance introduces additional nonlinear damping effects. Large-angle oscillations require the full nonlinear equation without the small-angle approximation. 6. Advanced Visualizations To better analyze the system, we can visualize: Phase Portraits: Plotting \\(\\theta\\) vs. \\(d\\theta/dt\\) to observe periodic and chaotic behavior. Poincar\u00e9 Sections: Sampling the phase space at regular time intervals. Bifurcation Diagrams: Varying \\(A\\) or \\(\\omega\\) to observe transitions between periodic and chaotic motion. 7. Conclusion The forced damped pendulum showcases rich dynamical behavior, from simple oscillations to chaotic motion. By adjusting parameters, we can explore resonance, synchronization, and chaotic regimes. This system has far-reaching applications in engineering, physics, and even biological systems such as gait dynamics and neural oscillations. This study highlights the need for both analytical and numerical approaches to fully understand nonlinear systems. Future work can involve adding noise, considering variable damping, or exploring non-periodic driving forces.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system with intricate behavior resulting from the interplay of damping, restoring forces, and external driving forces. By introducing both damping and external periodic forcing, the system demonstrates a transition from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena serve as a foundation for understanding complex real-world systems, such as driven oscillators, climate systems, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. By systematically varying these parameters, a diverse class of solutions can be observed, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications such as energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. For small angles, we approximate \\(\\sin\\theta \\approx \\theta\\) , leading to the linearized equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\]","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) is close to the system's natural frequency \\(\\omega_0\\) . This leads to an increase in amplitude, potentially causing instability or breakdown of the approximation.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The damping coefficient \\(b\\) controls energy dissipation. The driving amplitude \\(A\\) determines how strongly the external force influences the motion. The driving frequency \\(\\omega\\) dictates whether resonance or chaotic motion occurs. The transition to chaotic motion can be studied by analyzing phase space diagrams and Poincar\u00e9 sections.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Used in piezoelectric devices that convert mechanical vibrations into electrical energy. Structural Engineering : Suspension bridges and tall buildings experience forced oscillations due to wind and earthquakes. Electronics : Analogous to driven RLC circuits in electrical engineering.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"To analyze the forced damped pendulum, we use Python to numerically solve the governing differential equation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equation of motion for the forced damped pendulum def forced_damped_pendulum(t, y, b, omega0, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving force frequency # Initial conditions theta0 = 0.1 # Initial angle omega_dot0 = 0 # Initial angular velocity y0 = [theta0, omega_dot0] # Time range for the simulation t_span = (0, 50) # Simulation time t_eval = np.linspace(*t_span, 1000) # Time steps # Solve the differential equation solution = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, omega0, A, omega)) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=r'$\\theta(t)$', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-discussion-on-model-limitations","text":"The model assumes a simple sinusoidal driving force; real-world forces may be more complex. Air resistance introduces additional nonlinear damping effects. Large-angle oscillations require the full nonlinear equation without the small-angle approximation.","title":"5. Discussion on Model Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-advanced-visualizations","text":"To better analyze the system, we can visualize: Phase Portraits: Plotting \\(\\theta\\) vs. \\(d\\theta/dt\\) to observe periodic and chaotic behavior. Poincar\u00e9 Sections: Sampling the phase space at regular time intervals. Bifurcation Diagrams: Varying \\(A\\) or \\(\\omega\\) to observe transitions between periodic and chaotic motion.","title":"6. Advanced Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-conclusion","text":"The forced damped pendulum showcases rich dynamical behavior, from simple oscillations to chaotic motion. By adjusting parameters, we can explore resonance, synchronization, and chaotic regimes. This system has far-reaching applications in engineering, physics, and even biological systems such as gait dynamics and neural oscillations. This study highlights the need for both analytical and numerical approaches to fully understand nonlinear systems. Future work can involve adding noise, considering variable damping, or exploring non-periodic driving forces.","title":"7. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) Function to create circular orbit coordinates def circular_orbit(radius, period, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y Define planets data (radius in AU, period in years) planets = { 'Mercury': (0.39, 0.24), 'Venus': (0.72, 0.62), 'Earth': (1.0, 1.0), 'Mars': (1.52, 1.88), 'Jupiter': (5.20, 11.86) } Convert AU to meters and years to seconds for calculations AU = 1.496e11 # 1 AU in meters year = 365.25 * 24 * 3600 # 1 year in seconds Calculate T^2/r^3 for each planet t2_r3_values = {} for planet, (r_au, t_yr) in planets.items(): r = r_au * AU t = t_yr * year t2_r3 = (t 2) / (r 3) t2_r3_values[planet] = t2_r3 Calculate theoretical value of 4\u03c0\u00b2/(G*M_sun) theoretical = 4 * np.pi**2 / (G * M_sun) Plot orbits plt.figure(figsize=(10, 10)) plt.title('Planetary Orbits in the Solar System (Not to Scale)', fontsize=14) colors = ['gray', 'orange', 'blue', 'red', 'brown'] for i, (planet, (radius, _)) in enumerate(planets.items()): x, y = circular_orbit(radius, planets[planet][1]) plt.plot(x, y, label=planet, color=colors[i]) plt.plot(0, 0, 'yo', markersize=15, label='Sun') plt.grid(True, alpha=0.3) plt.legend(fontsize=12) plt.axis('equal') plt.xlabel('Distance (AU)', fontsize=12) plt.ylabel('Distance (AU)', fontsize=12) plt.savefig('solar_system_orbits.png', dpi=300, bbox_inches='tight') Plot T^2 vs r^3 plt.figure(figsize=(10, 6)) plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\", fontsize=14) r3_values = [] t2_values = [] for planet, (r, t) in planets.items(): r3 = r 3 t2 = t 2 r3_values.append(r3) t2_values.append(t2) plt.scatter(r3, t2, s=100, label=planet) Add best fit line plt.plot(np.array(r3_values), np.array(r3_values), 'k--', alpha=0.7, label='T\u00b2 = r\u00b3') plt.xlabel('r\u00b3 (AU\u00b3)', fontsize=12) plt.ylabel('T\u00b2 (years\u00b2)', fontsize=12) plt.grid(True, alpha=0.3) plt.legend(fontsize=12) plt.savefig('kepler_third_law.png', dpi=300, bbox_inches='tight') Create an animation of the orbits def animate_orbits(): fig, ax = plt.subplots(figsize=(10, 10)) ax.set_title('Planetary Motion in the Solar System (Time-scaled)', fontsize=14) ax.grid(True, alpha=0.3) ax.set_xlim(-6, 6) ax.set_ylim(-6, 6) ax.set_xlabel('Distance (AU)', fontsize=12) ax.set_ylabel('Distance (AU)', fontsize=12) ax.plot(0, 0, 'yo', markersize=15) # Sun # Create orbit lines orbit_lines = [] planet_dots = [] for i, (planet, (radius, _)) in enumerate(planets.items()): x, y = circular_orbit(radius, planets[planet][1]) orbit_line, = ax.plot(x, y, alpha=0.3, color=colors[i]) planet_dot, = ax.plot([], [], 'o', color=colors[i], markersize=10, label=planet) orbit_lines.append(orbit_line) planet_dots.append(planet_dot) ax.legend(fontsize=12) # Set different speeds proportional to actual orbital periods speeds = [2*np.pi/period for _, period in planets.values()] max_speed = max(speeds) speeds = [s/max_speed*0.1 for s in speeds] # Normalize speeds def init(): for dot in planet_dots: dot.set_data([], []) return planet_dots def animate(i): for j, ((_, (radius, _)), dot, speed) in enumerate(zip(planets.items(), planet_dots, speeds)): angle = i * speed x = radius * np.cos(angle) y = radius * np.sin(angle) dot.set_data(x, y) return planet_dots ani = FuncAnimation(fig, animate, frames=200, init_func=init, blit=True, interval=50) return ani Create and display the animation ani = animate_orbits() plt.close() # Close the animation figure to avoid displaying it twice Print verification of Kepler's Third Law print(\"Verification of Kepler's Third Law:\") print(f\"{'Planet':<10} {'T\u00b2/r\u00b3 (s\u00b2/m\u00b3)':<20} {'% of theoretical':<15}\") print(\"-\" * 45) for planet, value in t2_r3_values.items(): percentage = (value / theoretical) * 100 print(f\"{planet:<10} {value:.6e} {percentage:.2f}%\") print(\"\\nTheoretical value (4\u03c0\u00b2/GM_sun):\", f\"{theoretical:.6e}\") Print the relation in more intuitive units print(\"\\nIn more intuitive units:\") print(\"For planets orbiting the Sun: T\u00b2 (in years) \u2248 r\u00b3 (in AU)\") Demonstrate the use of Kepler's Third Law for mass calculation print(\"\\nUsing Kepler's Third Law to calculate the Sun's mass:\") r_earth = 1.0 * AU # Earth's orbital radius in meters t_earth = 1.0 * year # Earth's orbital period in seconds calculated_mass = 4 * np.pi 2 * r_earth 3 / (G * t_earth* 2) print(f\"Calculated Sun's mass: {calculated_mass:.3e} kg\") print(f\"Actual Sun's mass: {M_sun:.3e} kg\") print(f\"Difference: {abs(calculated_mass - M_sun)/M_sun 100:.4f}%\")","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#function-to-create-circular-orbit-coordinates","text":"def circular_orbit(radius, period, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y","title":"Function to create circular orbit coordinates"},{"location":"1%20Physics/2%20Gravity/Problem_1/#define-planets-data-radius-in-au-period-in-years","text":"planets = { 'Mercury': (0.39, 0.24), 'Venus': (0.72, 0.62), 'Earth': (1.0, 1.0), 'Mars': (1.52, 1.88), 'Jupiter': (5.20, 11.86) }","title":"Define planets data (radius in AU, period in years)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#convert-au-to-meters-and-years-to-seconds-for-calculations","text":"AU = 1.496e11 # 1 AU in meters year = 365.25 * 24 * 3600 # 1 year in seconds","title":"Convert AU to meters and years to seconds for calculations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculate-t2r3-for-each-planet","text":"t2_r3_values = {} for planet, (r_au, t_yr) in planets.items(): r = r_au * AU t = t_yr * year t2_r3 = (t 2) / (r 3) t2_r3_values[planet] = t2_r3","title":"Calculate T^2/r^3 for each planet"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculate-theoretical-value-of-42gm_sun","text":"theoretical = 4 * np.pi**2 / (G * M_sun)","title":"Calculate theoretical value of 4\u03c0\u00b2/(G*M_sun)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-orbits","text":"plt.figure(figsize=(10, 10)) plt.title('Planetary Orbits in the Solar System (Not to Scale)', fontsize=14) colors = ['gray', 'orange', 'blue', 'red', 'brown'] for i, (planet, (radius, _)) in enumerate(planets.items()): x, y = circular_orbit(radius, planets[planet][1]) plt.plot(x, y, label=planet, color=colors[i]) plt.plot(0, 0, 'yo', markersize=15, label='Sun') plt.grid(True, alpha=0.3) plt.legend(fontsize=12) plt.axis('equal') plt.xlabel('Distance (AU)', fontsize=12) plt.ylabel('Distance (AU)', fontsize=12) plt.savefig('solar_system_orbits.png', dpi=300, bbox_inches='tight')","title":"Plot orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t2-vs-r3","text":"plt.figure(figsize=(10, 6)) plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\", fontsize=14) r3_values = [] t2_values = [] for planet, (r, t) in planets.items(): r3 = r 3 t2 = t 2 r3_values.append(r3) t2_values.append(t2) plt.scatter(r3, t2, s=100, label=planet)","title":"Plot T^2 vs r^3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#add-best-fit-line","text":"plt.plot(np.array(r3_values), np.array(r3_values), 'k--', alpha=0.7, label='T\u00b2 = r\u00b3') plt.xlabel('r\u00b3 (AU\u00b3)', fontsize=12) plt.ylabel('T\u00b2 (years\u00b2)', fontsize=12) plt.grid(True, alpha=0.3) plt.legend(fontsize=12) plt.savefig('kepler_third_law.png', dpi=300, bbox_inches='tight')","title":"Add best fit line"},{"location":"1%20Physics/2%20Gravity/Problem_1/#create-an-animation-of-the-orbits","text":"def animate_orbits(): fig, ax = plt.subplots(figsize=(10, 10)) ax.set_title('Planetary Motion in the Solar System (Time-scaled)', fontsize=14) ax.grid(True, alpha=0.3) ax.set_xlim(-6, 6) ax.set_ylim(-6, 6) ax.set_xlabel('Distance (AU)', fontsize=12) ax.set_ylabel('Distance (AU)', fontsize=12) ax.plot(0, 0, 'yo', markersize=15) # Sun # Create orbit lines orbit_lines = [] planet_dots = [] for i, (planet, (radius, _)) in enumerate(planets.items()): x, y = circular_orbit(radius, planets[planet][1]) orbit_line, = ax.plot(x, y, alpha=0.3, color=colors[i]) planet_dot, = ax.plot([], [], 'o', color=colors[i], markersize=10, label=planet) orbit_lines.append(orbit_line) planet_dots.append(planet_dot) ax.legend(fontsize=12) # Set different speeds proportional to actual orbital periods speeds = [2*np.pi/period for _, period in planets.values()] max_speed = max(speeds) speeds = [s/max_speed*0.1 for s in speeds] # Normalize speeds def init(): for dot in planet_dots: dot.set_data([], []) return planet_dots def animate(i): for j, ((_, (radius, _)), dot, speed) in enumerate(zip(planets.items(), planet_dots, speeds)): angle = i * speed x = radius * np.cos(angle) y = radius * np.sin(angle) dot.set_data(x, y) return planet_dots ani = FuncAnimation(fig, animate, frames=200, init_func=init, blit=True, interval=50) return ani","title":"Create an animation of the orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#create-and-display-the-animation","text":"ani = animate_orbits() plt.close() # Close the animation figure to avoid displaying it twice","title":"Create and display the animation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#print-verification-of-keplers-third-law","text":"print(\"Verification of Kepler's Third Law:\") print(f\"{'Planet':<10} {'T\u00b2/r\u00b3 (s\u00b2/m\u00b3)':<20} {'% of theoretical':<15}\") print(\"-\" * 45) for planet, value in t2_r3_values.items(): percentage = (value / theoretical) * 100 print(f\"{planet:<10} {value:.6e} {percentage:.2f}%\") print(\"\\nTheoretical value (4\u03c0\u00b2/GM_sun):\", f\"{theoretical:.6e}\")","title":"Print verification of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#print-the-relation-in-more-intuitive-units","text":"print(\"\\nIn more intuitive units:\") print(\"For planets orbiting the Sun: T\u00b2 (in years) \u2248 r\u00b3 (in AU)\")","title":"Print the relation in more intuitive units"},{"location":"1%20Physics/2%20Gravity/Problem_1/#demonstrate-the-use-of-keplers-third-law-for-mass-calculation","text":"print(\"\\nUsing Kepler's Third Law to calculate the Sun's mass:\") r_earth = 1.0 * AU # Earth's orbital radius in meters t_earth = 1.0 * year # Earth's orbital period in seconds calculated_mass = 4 * np.pi 2 * r_earth 3 / (G * t_earth* 2) print(f\"Calculated Sun's mass: {calculated_mass:.3e} kg\") print(f\"Actual Sun's mass: {M_sun:.3e} kg\") print(f\"Difference: {abs(calculated_mass - M_sun)/M_sun 100:.4f}%\")","title":"Demonstrate the use of Kepler's Third Law for mass calculation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}